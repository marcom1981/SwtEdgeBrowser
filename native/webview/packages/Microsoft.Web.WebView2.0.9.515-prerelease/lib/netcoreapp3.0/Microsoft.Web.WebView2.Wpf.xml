<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Web.WebView2.Wpf</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties">
            <summary>
            This class is a bundle of the most common parameters used to create a <see cref="T:Microsoft.Web.WebView2.Core.CoreWebView2Environment"/>.
            Its main purpose is to be set to <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CreationProperties"/> in order to customize the environment used by a <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> during implicit initialization.
            It is also a nice WPF integration utility which allows commonly used environment parameters to be dependency properties and be created and used in markup.
            </summary>
            <remarks>
            This class isn't intended to contain all possible environment customization options.
            If you need complete control over the environment used by a WebView2 control then you'll need to initialize the control explicitly by
            creating your own environment with <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2Environment.CreateAsync(System.String,System.String,Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions)"/> and passing it to <see cref="M:Microsoft.Web.WebView2.Wpf.WebView2.EnsureCoreWebView2Async(Microsoft.Web.WebView2.Core.CoreWebView2Environment)"/>
            *before* you set the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.Source"/> property to anything.
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </remarks>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties"/> with default data for all properties.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.BrowserExecutableFolderProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.BrowserExecutableFolder"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.BrowserExecutableFolder">
            <summary>
            Gets or sets the value to pass as the browserExecutableFolder parameter of <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2Environment.CreateAsync(System.String,System.String,Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions)"/> when creating an environment with this instance.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.UserDataFolderProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.UserDataFolder"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.UserDataFolder">
            <summary>
            Gets or sets the value to pass as the userDataFolder parameter of <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2Environment.CreateAsync(System.String,System.String,Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions)"/> when creating an environment with this instance.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.LanguageProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.Language"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.Language">
            <summary>
            Gets or sets the value to use for the Language property of the CoreWebView2EnvironmentOptions parameter passed to <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2Environment.CreateAsync(System.String,System.String,Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions)"/> when creating an environment with this instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.CoreWebView2CreationProperties.CreateEnvironmentAsync">
            <summary>
            Create a <see cref="T:Microsoft.Web.WebView2.Core.CoreWebView2Environment"/> using the current values of this instance's properties.
            </summary>
            <returns>A task which will provide the created environment on completion.</returns>
            <remarks>
            As long as no other properties on this instance are changed, repeated calls to this method will return the same task/environment as earlier calls.
            If some other property is changed then the next call to this method will return a different task/environment.
            </remarks>
        </member>
        <member name="T:Microsoft.Web.WebView2.Wpf.WebView2">
            <summary>
            A control to embed web content in a WPF application.
            </summary>
            <remarks>
            This control is effectively a wrapper around the WebView2 COM API, which you can find documentation for here: https://docs.microsoft.com/microsoft-edge/hosting/webview2
            You can directly access the underlying ICoreWebView2 interface and all of its functionality by accessing the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> property.
            Some of the most common COM functionality is also accessible directly through wrapper methods/properties/events on the control.
            
            Upon creation, the control's CoreWebView2 property will be null.
            This is because creating the CoreWebView2 is an expensive operation which involves things like launching Edge browser processes.
            There are two ways to cause the CoreWebView2 to be created:
            1) Call the <see cref="M:Microsoft.Web.WebView2.Wpf.WebView2.EnsureCoreWebView2Async(Microsoft.Web.WebView2.Core.CoreWebView2Environment)"/> method.  This is referred to as explicit initialization.
            2) Set the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.Source"/> property (which could be done from markup, for example).  This is referred to as implicit initialization.
            Either option will start initialization in the background and return back to the caller without waiting for it to finish.
            To specify options regarding the initialization process, either pass your own <see cref="T:Microsoft.Web.WebView2.Core.CoreWebView2Environment"/> to EnsureCoreWebView2Async or set the control's <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CreationProperties"/> property prior to initialization.
            
            When initialization has finished (regardless of how it was triggered) then the following things will occur, in this order:
            1) The control's <see cref="E:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Ready"/> event will be invoked.  If you need to perform one time setup operations on the CoreWebView2 prior to its use then you should do so in a handler for that event.
            2) If a Uri has been set to the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.Source"/> property then the control will start navigating to it in the background (i.e. these steps will continue without waiting for the navigation to finish).
            3) The Task returned from <see cref="M:Microsoft.Web.WebView2.Wpf.WebView2.EnsureCoreWebView2Async(Microsoft.Web.WebView2.Core.CoreWebView2Environment)"/> will complete.
            
            For more details about any of the methods/properties/events involved in the initialization process, see its specific documentation.
            
            Because the control's CoreWebView2 is a very heavyweight object (potentially responsible for multiple running processes and megabytes of disk space) the control implements IDisposable to provide an explicit means to free it.
            Calling Dispose will release the CoreWebView2 and its underlying resources (except any that are also being used by other WebViews), and reset CoreWebView2 to null.
            After Dispose has been called the CoreWebView2 cannot be re-initialized, and any attempt to use functionality which requires it will throw an ObjectDisposedException.
            
            Note that this control extends HwndHost in order to embed windows which live outside of the WPF ecosystem.
            This has some implications regarding the control's input and output behavior as well as the functionality it "inherits" from UIElement and FrameworkElement.
            See the HwndHost and WPF/Win32 interop documentation for more info:
            * https://docs.microsoft.com/dotnet/api/system.windows.interop.hwndhost
            * https://docs.microsoft.com/dotnet/framework/wpf/advanced/wpf-and-win32-interoperation#hwnds-inside-wpf
            </remarks>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.#ctor">
            <summary>
            Creates a new instance of a WebView2 control.
            Note that the control's <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> will be null until initialized.
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.WebView2.CreationPropertiesProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CreationProperties"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.WebView2.CreationProperties">
            <summary>
            Gets or sets a bag of options which are used during initialization of the control's <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            Setting this property won't work after initialization of the control's CoreWebView2 has started (the old value will be retained).
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.BuildWindowCore(System.Runtime.InteropServices.HandleRef)">
            <summary>
            This is overridden from HwndHost and is called to instruct us to create our HWND.
            </summary>
            <param name="hwndParent">The HWND that we should use as the parent of the one we create.</param>
            <returns>The HWND that we created.</returns>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.DestroyWindowCore(System.Runtime.InteropServices.HandleRef)">
            <summary>
            This is overridden from HwndHost and is called to instruct us to destroy our HWND.
            </summary>
            <param name="hwnd">Our HWND that we need to destroy.</param>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2">
            <summary>
            Access the complete functionality of the underlying <see cref="T:Microsoft.Web.WebView2.Core.CoreWebView2"/> COM API.
            Returns null until initialization has completed.
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Ready">
            <summary>
            This event is triggered when the control's <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> has finished being initialized (regardless of how initialization was triggered) but before it is used for anything.
            You should handle this event if you need to perform one time setup operations on the CoreWebView2 which you want to affect all of its usages
            (e.g. adding event handlers, configuring settings, installing document creation scripts, adding host objects).
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
            <remarks>
            This event doesn't provide any arguments, and the sender will be the WebView2 control, whose CoreWebView2 property will now be valid (i.e. non-null) for the first time.
            </remarks>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.EnsureCoreWebView2Async(Microsoft.Web.WebView2.Core.CoreWebView2Environment)">
            <summary>
            Explicitly trigger initialization of the control's <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
            <param name="environment">
            A pre-created <see cref="T:Microsoft.Web.WebView2.Core.CoreWebView2Environment"/> that should be used to create the CoreWebView2.
            Creating your own environment gives you control over several options that affect how the CoreWebView2 is initialized.
            If you pass an environment to this method then it will override any settings specified on the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CreationProperties"/> property.
            If you pass null (the default value) and no value has been set to CreationProperties then a default environment will be created and used automatically.
            </param>
            <returns>
            A Task that represents the background initialization process.
            When the task completes then the CoreWebView2 property will be available for use (i.e. non-null).
            Note that the control's <see cref="E:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Ready"/> event will be invoked before the task completes.
            </returns>
            <remarks>
            Calling this method additional times will have no effect (any specified environment is ignored) and return the same Task as the first call.
            Calling this method after initialization has been implicitly triggered by setting the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.Source"/> property will have no effect (any specified environment is ignored) and simply return a Task representing that initialization already in progress.
            Note that even though this method is asynchronous and returns a Task, it still must be called on the UI thread like most public functionality of most UI controls.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.Dispose(System.Boolean)">
            <summary>
            This is called by our base class according to the typical implementation of the IDispose pattern.
            We implement it by releasing all of our underlying COM resources, including our <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            </summary>
            <param name="disposing">True if a caller is explicitly calling Dispose, false if we're being finalized.</param>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.UIElement_IsVisibleChanged(System.Object,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            This is a handler for our base UIElement's IsVisibleChanged event.
            It's predictably fired whenever IsVisible changes, and IsVisible reflects the actual current visibility status of the control.
            We just need to pass this info through to our CoreWebView2Controller so it can save some effort when the control isn't visible.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.OnWindowPositionChanged(System.Windows.Rect)">
            <summary>
            This is overridden from HwndHost and called when our control's location has changed.
            The HwndHost takes care of updating the HWND we created.
            What we need to do is move our CoreWebView2 to match the new location.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.WebView2.SourceProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.Source"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.WebView2.Source">
            <summary>
            The top-level Uri which the WebView is currently displaying (or will display once initialization of its <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> is finished).
            Generally speaking, getting this property is equivalent to getting the <see cref="P:Microsoft.Web.WebView2.Core.CoreWebView2.Source"/> property of CoreWebView2 and setting this property is equivalent to calling the <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.Navigate(System.String)"/> method on CoreWebView2.
            Getting this property before the CoreWebView2 has been initialized will retrieve the last Uri which was set to it.
            Setting this property before the CoreWebView2 has been initialized will cause initialization to start in the background (if not already in progress), after which the WebView2 will navigate to the specified Uri.
            See the <see cref="T:Microsoft.Web.WebView2.Wpf.WebView2"/> class documentation for an initialization overview.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.SourcePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            This is a callback that WPF calls when the our WPF Source property's value changes.
            This might have been triggered by either:
            1) The caller set Source to programmatically trigger a navigation.
            2) The CoreWebView changed its own source and we're just updating the dependency property to match.
            We need to distinguish between these two cases so that we know whether to trigger a navigation.
            We distinguish by using the _sourceChangingByCore flag.
            </summary>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.SourceChanged">
            <summary>
            A wrapper around the <see cref="E:Microsoft.Web.WebView2.Core.CoreWebView2.SourceChanged"/> event of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            The only difference between this event and CoreWebView2.SourceChanged is the first parameter that's passed to handlers.
            Handlers of this event will receive the WebView2 control, whereas handlers of CoreWebView2.SourceChanged will receive the CoreWebView2 instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_SourceChanged(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2SourceChangedEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2's SourceChanged event.
            Unsurprisingly, it fires when the CoreWebView2's source URI has been changed.
            Note that there are two distinct triggers for this:
            1) The CoreWebView2 was told to navigate programmatically (potentially by us, see SourcePropertyChanged).
            2) The user interacted with the CoreWebView2, e.g. clicked a link.
            In either of the above cases, this event might trigger several times due to e.g. redirection.
            Aside from propagating the event to WPF, we just need to update our WPF Source property to match the CoreWebView2's.
            </summary>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.NavigationStarting">
            <summary>
            A wrapper around the <see cref="E:Microsoft.Web.WebView2.Core.CoreWebView2.NavigationStarting"/> event of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            The only difference between this event and CoreWebView2.NavigationStarting is the first parameter that's passed to handlers.
            Handlers of this event will receive the WebView2 control, whereas handlers of CoreWebView2.NavigationStarting will receive the CoreWebView2 instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_NavigationStarting(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2's NavigationStarting event.
            We just need to propagate the event to WPF.
            </summary>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.NavigationCompleted">
            <summary>
            A wrapper around the <see cref="E:Microsoft.Web.WebView2.Core.CoreWebView2.NavigationCompleted"/> event of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            The only difference between this event and CoreWebView2.NavigationCompleted is the first parameter that's passed to handlers.
            Handlers of this event will receive the WebView2 control, whereas handlers of CoreWebView2.NavigationCompleted will receive the CoreWebView2 instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_NavigationCompleted(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2NavigationCompletedEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2's NavigationCompleted event.
            We just need to propagate the event to WPF.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_HistoryChanged(System.Object,System.Object)">
            <summary>
            This is an event handler for our CoreWebView2's HistoryChanged event.
            We're handling it in order to update our WPF CanGoBack and CanGoForward properties.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.WebView2.CanGoBackProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CanGoBack"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.WebView2.CanGoBack">
            <summary>
            Returns true if the WebView can navigate to a previous page in the navigation history.
            Wrapper around the <see cref="P:Microsoft.Web.WebView2.Core.CoreWebView2.CanGoBack"/> property of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            If CoreWebView2 isn't initialized yet then returns false.
            </summary>
        </member>
        <member name="F:Microsoft.Web.WebView2.Wpf.WebView2.CanGoForwardProperty">
            <summary>
            The WPF DependencyProperty which backs the <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CanGoForward"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.Web.WebView2.Wpf.WebView2.CanGoForward">
            <summary>
            Returns true if the WebView can navigate to a next page in the navigation history.
            Wrapper around the <see cref="P:Microsoft.Web.WebView2.Core.CoreWebView2.CanGoForward"/> property of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            If CoreWebView2 isn't initialized yet then returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.TabIntoCore(System.Windows.Input.TraversalRequest)">
            <summary>
            This is overridden from HwndHost and is called to inform us that tabbing has caused the focus to move into our control/window.
            Since WPF can't manage the transition of focus to a non-WPF HWND, it delegates the transition to us here.
            So our job is just to place the focus in our external HWND.
            </summary>
            <param name="request">Information about how the focus is moving.</param>
            <returns>True to indicate that we handled the navigation, or false to indicate that we didn't.</returns>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Controller_MoveFocusRequested(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2MoveFocusRequestedEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2Controller's MoveFocusRequested event.
            It fires when the CoreWebView2Controller has focus but wants to move it elsewhere in the app.
            E.g. this happens when the user tabs past the last item in the CoreWebView2 and focus needs to return to some other app control.
            So our job is just to tell WPF to move the focus on to the next control.
            Note that we don't propagate this event outward as a standard WPF routed event because we've implemented its purpose here.
            If users of the control want to track focus shifting in/out of the control, they should use standard WPF events.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.HasFocusWithinCore">
            <summary>
            This is overridden from HwndHost and is called when WPF needs to know if the focus is in our control/window.
            WPF can't know on its own since we're hosting a non-WPF window, so instead it asks us by calling this.
            To answer, we just track state based on CoreWebView2 events that fire when it gains or loses focus.
            </summary>
            <returns>True if the focus is in our control/window, false if it isn't.</returns>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Controller_GotFocus(System.Object,System.Object)">
            <summary>
            This is an event handler for our CoreWebView2Controller's GotFocus event.
            Aside from propagating the event to WPF, we just need to update our internal _hasFocus state.
            That state is used when HwndHost needs to know if our HWND contains the focus (see HasFocusWithinCore).
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Controller_LostFocus(System.Object,System.Object)">
            <summary>
            This is an event handler for our CoreWebView2Controller's LostFocus event.
            Aside from propagating the event to WPF, we just need to update our internal _hasFocus state.
            That state is used when HwndHost needs to know if our HWND contains the focus (see HasFocusWithinCore).
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2Controller_AcceleratorKeyPressed(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2Controller's AcceleratorKeyPressed event.
            This is called to inform us about key presses that are likely to have special behavior (e.g. esc, return, Function keys, letters with modifier keys).
            WPF can't detect this input because Windows sends it directly to the Win32 CoreWebView2Controller control.
            We implement this by generating standard WPF key input events, allowing callers to handle the input in the usual WPF way if they want.
            If nobody handles the WPF key events then we'll allow the default CoreWebView2Controller logic (if any) to handle it.
            Of the possible options, this implementation should provide the most flexibility to callers.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <summary>
            This is overridden from UIElement and called to allow us to handle key press input.
            WPF should never actually call this in response to keyboard events because we're hosting a non-WPF window.
            When our window has focus Windows will send the input directly to it rather than to WPF's top-level window and input system.
            This override should only be called when we're explicitly forwarding accelerator key input from the CoreWebView2 to WPF (in CoreWebView2Controller_AcceleratorKeyPressed).
            Even then, this KeyDownEvent is only triggered because our PreviewKeyDownEvent implementation explicitly triggers it, matching WPF's usual system.
            So the process is:
                CoreWebView2Controller_AcceleratorKeyPressed -> raise PreviewKeyDownEvent -> OnPreviewKeyDown -> raise KeyDownEvent -> OnKeyDown
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <summary>
            See OnKeyDown.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
            <summary>
            This is the "Preview" (i.e. tunneling) version of OnKeyDown, so it actually happens first.
            Like OnKeyDown, this will only ever be called if we're explicitly forwarding key presses from the CoreWebView2.
            In order to mimic WPF's standard input handling, when we receive this we turn around and fire off the standard bubbling KeyDownEvent.
            That way others in the WPF tree see the same standard pair of input events that WPF itself would have triggered if it were handling the key press.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
            <summary>
            See OnPreviewKeyDown.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.GoBack">
            <summary>
            Navigates the WebView to the previous page in the navigation history.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.GoBack"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            If CoreWebView2 hasn't been initialized yet then does nothing.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.GoForward">
            <summary>
            Navigates the WebView to the next page in the navigation history.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.GoForward"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            If CoreWebView2 hasn't been initialized yet then does nothing.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.Reload">
            <summary>
            Reloads the current page.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.Reload"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> hasn't been initialized yet.</exception>"
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.Stop">
            <summary>
            Stops all navigations and pending resource fetches.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.Stop"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> hasn't been initialized yet.</exception>"
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.NavigateToString(System.String)">
            <summary>
            Initiates a navigation to htmlContent as source HTML of a new document.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.NavigateToString(System.String)"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> hasn't been initialized yet.</exception>"
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.ContentLoading">
            <summary>
            A wrapper around the <see cref="E:Microsoft.Web.WebView2.Core.CoreWebView2.ContentLoading"/> event of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            The only difference between this event and CoreWebView2.ContentLoading is the first parameter that's passed to handlers.
            Handlers of this event will receive the WebView2 control, whereas handlers of CoreWebView2.ContentLoading will receive the CoreWebView2 instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_ContentLoading(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2ContentLoadingEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2's ContentLoading event.
            We just need to propagate the event to WPF.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.ExecuteScriptAsync(System.String)">
            <summary>
            Executes JavaScript code from the javaScript parameter in the current top level document rendered in the WebView.
            Equivalent to calling <see cref="M:Microsoft.Web.WebView2.Core.CoreWebView2.ExecuteScriptAsync(System.String)"/> on <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/> hasn't been initialized yet.</exception>"
            <exception cref="T:System.InvalidOperationException">Thrown if the calling thread isn't the thread which created this object (usually the UI thread).  See DispatcherObject.VerifyAccess for more info.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if Dispose has already been called on the control.</exception>
        </member>
        <member name="E:Microsoft.Web.WebView2.Wpf.WebView2.WebMessageReceived">
            <summary>
            A wrapper around the <see cref="E:Microsoft.Web.WebView2.Core.CoreWebView2.WebMessageReceived"/> event of <see cref="P:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2"/>.
            The only difference between this event and CoreWebView2.WebMessageReceived is the first parameter that's passed to handlers.
            Handlers of this event will receive the WebView2 control, whereas handlers of CoreWebView2.WebMessageReceived will receive the CoreWebView2 instance.
            </summary>
        </member>
        <member name="M:Microsoft.Web.WebView2.Wpf.WebView2.CoreWebView2_WebMessageReceived(System.Object,Microsoft.Web.WebView2.Core.CoreWebView2WebMessageReceivedEventArgs)">
            <summary>
            This is an event handler for our CoreWebView2's WebMessageReceived event.
            We just need to propagate the event to WPF.
            </summary>
        </member>
    </members>
</doc>
